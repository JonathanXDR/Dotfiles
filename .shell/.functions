#!/usr/bin/env bash

# ---------------------------- Shell & PATH Utils ---------------------------- #


print() {
  local level="$1"
  local red='\033[0;31m'
  local green='\033[0;32m'
  local yellow='\033[0;33m'
  local blue='\033[0;34m'
  local reset='\033[0m'

  case "$level" in
    error|red)    shift; printf "${red}[ERROR] %s${reset}\n" "$*";;
    success|green)  shift; printf "${green}[SUCCESS] %s${reset}\n" "$*";;
    warning|yellow) shift; printf "${yellow}[WARN] %s${reset}\n" "$*";;
    info|blue)      shift; printf "${blue}[INFO] %s${reset}\n" "$*";;
    *)              echo "$@";;
  esac
}

cmd:exists() {
  [[ $# -eq 1 ]] || {
    echo "Usage: cmd:exists <command>" >&2
    return 1
  }
  if command -v "$1" &>/dev/null; then
    return 0
  else
    print error "Command $1 not found" >&2
    return 1
  fi
}

# PATH utility function (build once, mind order)
# Safely adds a directory to PATH only if it exists and isn't already there
path:add() {
  [[ -d "$1" ]] && case ":$PATH:" in
    *":$1:"*) ;;
    *) export PATH="$1:$PATH" ;;
  esac
}

# PATH utility function for appending (less common, but useful)
path:append() {
  [[ -d "$1" ]] && case ":$PATH:" in
    *":$1:"*) ;;
    *) export PATH="$PATH:$1" ;;
  esac
}

# Create a new directory and enter it
mkd() {
	mkdir -p "$@" && cd "$_" || exit;
}

# Change working directory to the top-most Finder window location
cdf() { # short for `cdfinder`
	cd "$(osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)')" || exit;
}

# ----------------------------- Files & Archives ----------------------------- #

# Create a .tar.gz archive, using `zopfli`, `pigz` or `gzip` for compression
targz() {
  local tmpFile="${1%/}.tar";
  tar -cvf "${tmpFile}" --exclude=".DS_Store" "${@}" || return 1;

	size=$(
		stat -f"%z" "${tmpFile}" 2> /dev/null; # macOS `stat`
		stat -c"%s" "${tmpFile}" 2> /dev/null;  # GNU `stat`
	);

	local cmd="";
	if (( size < 52428800 )) && hash zopfli 2> /dev/null; then
		# the .tar file is smaller than 50 MB and Zopfli is available; use it
		cmd="zopfli";
	else
		if hash pigz 2> /dev/null; then
			cmd="pigz";
		else
			cmd="gzip";
		fi;
	fi;

	echo "Compressing .tar ($((size / 1000)) kB) using \`${cmd}\`…";
	"${cmd}" -v "${tmpFile}" || return 1;
	[ -f "${tmpFile}" ] && rm "${tmpFile}";

	zippedSize=$(
		stat -f"%z" "${tmpFile}.gz" 2> /dev/null; # macOS `stat`
		stat -c"%s" "${tmpFile}.gz" 2> /dev/null; # GNU `stat`
	);

	echo "${tmpFile}.gz ($((zippedSize / 1000)) kB) created successfully.";
}

# Determine size of a file or total size of a directory
fs() {
  if du -b /dev/null > /dev/null 2>&1; then
    local arg=-sbh;
  else
    local arg=-sh;
  fi
  if (( $# )); then
    du $arg -- "$@";
  else
    du $arg .[^.]* ./*;
  fi;
}

# Create a data URL from a file
dataurl() {
	# shellcheck disable=SC2155
	local mimeType=$(file -b --mime-type "$1");
	if [[ $mimeType == text/* ]]; then
		mimeType="${mimeType};charset=utf-8";
	fi
	echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')";
}

# Start an HTTP server from a directory, optionally specifying the port
server() {
	local port="${1:-8000}";
	sleep 1 && open "http://localhost:${port}/" &
	# Set the default Content-Type to `text/plain` instead of `application/octet-stream`
	# And serve everything as UTF-8 (although not technically correct, this doesn’t break anything for binary files)
	python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port";
}

# Compare original and gzipped file size
gz() {
  # shellcheck disable=SC2155
	local origsize=$(wc -c < "$1");
  # shellcheck disable=SC2155
	local gzipsize=$(gzip -c "$1" | wc -c);
  # shellcheck disable=SC2155
	local ratio=$(echo "$gzipsize * 100 / $origsize" | bc -l);
	printf "orig: %d bytes\n" "$origsize";
	printf "gzip: %d bytes (%2.2f%%)\n" "$gzipsize" "$ratio";
}

# `trec` is a shorthand for `tree color` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
trec() {
  tree -aC -I '.git|node_modules|bower_components' --dirsfirst "$@" | less -FRNX;
}

tre() {
  tree -a -I '.git|node_modules|bower_components' --dirsfirst "$@"
}

# ------------------------------ Open & Launch ------------------------------- #

# Normalize `open` across Linux, macOS, and Windows.
# This is needed to make the `o` function (see below) cross-platform.
if [ "$(uname -s)" != 'Darwin' ]; then
  if grep -q Microsoft /proc/version; then
    # Ubuntu on Windows using the Linux subsystem
    alias open='explorer.exe';
  else
    alias open='xdg-open';
  fi
fi

# `o` with no arguments opens the current directory, otherwise opens the given
# location
o() {
	if [ $# -eq 0 ]; then
		open .;
	else
		open "$@";
	fi;
}

# -------------------------- Networking, TLS & DNS --------------------------- #

# Run `dig` and display the most useful info
digga() {
	dig +nocmd "$1" any +multiline +noall +answer;
}

# Show all the names (CNs and SANs) listed in the SSL certificate
# for a given domain
getcertnames() {
	if [ -z "${1}" ]; then
		echo "ERROR: No domain specified.";
		return 1;
	fi;

	local domain="${1}";
	echo "Testing ${domain}…";
	echo ""; # newline

# shellcheck disable=SC2155
	local tmp=$(echo -e "GET / HTTP/1.0\nEOT" \
		| openssl s_client -connect "${domain}:443" -servername "${domain}" 2>&1);

	if [[ "${tmp}" = *"-----BEGIN CERTIFICATE-----"* ]]; then
    # shellcheck disable=SC2155
		local certText=$(echo "${tmp}" \
			| openssl x509 -text -certopt "no_aux, no_header, no_issuer, no_pubkey, \
			no_serial, no_sigdump, no_signame, no_validity, no_version");
		echo "Common Name:";
		echo ""; # newline
		echo "${certText}" | grep "Subject:" | sed -e "s/^.*CN=//" | sed -e "s/\/emailAddress=.*//";
		echo ""; # newline
		echo "Subject Alternative Name(s):";
		echo ""; # newline
		echo "${certText}" | grep -A 1 "Subject Alternative Name:" \
			| sed -e "2s/DNS://g" -e "s/ //g" | tr "," "\n" | tail -n +2;
		return 0;
	else
		echo "ERROR: Certificate not found.";
		return 1;
	fi;
}

dns:change() {
  if (($# < 2)); then
    echo "Usage: dns:change <network service name> <DNS IPs separated by commas>" >&2
    return 1
  fi

  local network_service="$1"
  IFS=',' read -ra nameservers <<<"$2"

  sudo networksetup -setdnsservers "${network_service}" "Empty" "${nameservers[@]}"
}

proxy:compose-addr() {
  [[ $# -eq 3 ]] || return 1
  printf "%s://%s:%s" "$1" "$2" "$3"
}

proxy:set() {
  local proxy_protocol="${1:-${PROXY_PROTOCOL}}"
  local proxy_host="${2:-${PROXY_HOST}}"
  local proxy_port="${3:-${PROXY_PORT}}"
  local no_proxy="${4:-${NO_PROXY}}"

  if [[ -z "${proxy_protocol}" || -z "${proxy_host}" || -z "${proxy_port}" ]]; then
    echo "Usage: proxy:set <protocol> <host> <port> [no_proxy]" >&2
    echo "Or ensure PROXY_PROTOCOL, PROXY_HOST, and PROXY_PORT are set in ${HOME}/.shell/.exports" >&2
    return 1
  fi

  # shellcheck disable=SC2155
  local proxy_addr="$(proxy:compose-addr "${proxy_protocol}" "${proxy_host}" "${proxy_port}")"

  export http_proxy="${proxy_addr}"
  export https_proxy="${proxy_addr}"
  export ftp_proxy="${proxy_addr}"
  export all_proxy="${proxy_addr}"
  export HTTP_PROXY="${proxy_addr}"
  export HTTPS_PROXY="${proxy_addr}"
  export FTP_PROXY="${proxy_addr}"
  export ALL_PROXY="${proxy_addr}"
  export PIP_PROXY="${proxy_addr}"
  export no_proxy="${no_proxy}"
  export NO_PROXY="${no_proxy}"
  export MAVEN_OPTS="-Dhttp.proxyHost=${proxy_host} -Dhttp.proxyPort=${proxy_port} -Dhttps.proxyHost=${proxy_host} -Dhttps.proxyPort=${proxy_port}"
}

proxy:unset() {
  unset http_proxy https_proxy ftp_proxy all_proxy HTTP_PROXY HTTPS_PROXY FTP_PROXY ALL_PROXY PIP_PROXY no_proxy NO_PROXY MAVEN_OPTS
}

proxy:probe() {
  local with_dns="${1:-}"
  if nc -z -w 3 "${PROXY_HOST}" "${PROXY_PORT}" &>/dev/null; then
    echo "Detected VPN, turning on proxy."
    proxy:set "${PROXY_PROTOCOL}" "${PROXY_HOST}" "${PROXY_PORT}" "${NO_PROXY}"
    [[ "${with_dns}" == "dns" ]] && dns:change "${PROXY_DNS:-},${NO_PROXY_DNS:-}"
  else
    # echo "Detected normal network, turning off proxy."
    proxy:unset
    [[ "${with_dns}" == "dns" ]] && dns:change "${NO_PROXY_DNS:-},${PROXY_DNS:-}"
  fi
}

network:check() {
  local cmd="$1" url="$2"
  if command -v "$cmd" >/dev/null 2>&1; then
    if command -v curl >/dev/null 2>&1 && curl -m3 -sSf "$url" >/dev/null 2>&1; then
      "$cmd"
    else
      print "Skipping $cmd (network unavailable or blocked)"
    fi
  fi
}

# ------------------------------------ SSH ----------------------------------- #

ssh:reagent() {
  for agent in /tmp/ssh-*/agent.*; do
    export SSH_AUTH_SOCK="${agent}"
    if ssh-add -l &>/dev/null; then
      echo "Found working SSH Agent:"
      ssh-add -l
      return 0
    fi
  done
  echo "Cannot find ssh agent - maybe you should reconnect and forward it?"
  return 1
}

ssh:agent() {
  pgrep -x ssh-agent &>/dev/null && ssh:reagent &>/dev/null || eval "$(ssh-agent)" &>/dev/null
}

# ---------------------------- macOS System Tweaks --------------------------- #

sudo:touch-id() {
  FILE='/etc/pam.d/sudo'
  BACKUP="$(mktemp /tmp/sudo.pam.backup.XXXXXX)"

  cleanup() {
    rm -f "$BACKUP"
  }
  trap cleanup EXIT

  trap 'echo "Error detected – restoring original file" >&2; sudo cp "$BACKUP" "$FILE"; exit 1' ERR

  echo "Backing up $FILE to $BACKUP…"
  sudo cp "$FILE" "$BACKUP"

  if ! sudo grep -q '^# sudo: auth account password session' "$FILE"; then
    echo "Required marker comment not found in $FILE" >&2
    exit 1
  fi

  if ! sudo grep -qF 'auth       sufficient     pam_tid.so' "$FILE"; then
    echo "Inserting pam_tid line…"
    sudo sed -i '' '/^# sudo: auth account password session/a\
auth       sufficient     pam_tid.so
' "$FILE"
  else
    echo "pam_tid line already present, skipping insertion."
  fi

  trap - ERR
  echo "Done. $FILE has been updated successfully."
}

dock:reset() {
  defaults delete com.apple.dock
  killall Dock
  sleep 5

  local apps=("Zen" "Notion" "Visual Studio Code" "Microsoft Teams" "Discord" "GitKraken")

  for app in "${apps[@]}"; do
    defaults write com.apple.dock persistent-apps -array-add "<dict><key>tile-data</key><dict><key>file-data</key><dict><key>_CFURLString</key><string>/Applications/${app}.app</string><key>_CFURLStringType</key><integer>0</integer></dict></dict></dict>"
  done

  defaults write com.apple.dock mineffect -string "scale"
  defaults write com.apple.dock minimize-to-application -bool true
  defaults write com.apple.dock launchanim -bool false
  defaults write com.apple.dock show-recents -bool false
  defaults write com.apple.dock expose-group-apps -bool true

  killall Dock
}

# ---------------------------------- Docker ---------------------------------- #

docker:cleanup() {
  if [[ $# -eq 0 ]]; then
    docker stop "$(docker ps -aq)" 2>/dev/null || true
    docker rm "$(docker ps -aq)" 2>/dev/null || true
    docker rmi "$(docker images -q)" 2>/dev/null || true
  else
    local keywords="$*"
    docker stop "$(docker ps -a --format '{{.ID}} {{.Names}}' | grep -vE "(${keywords})" | awk '{print $1}')" 2>/dev/null || true
    docker rm "$(docker ps -a --format '{{.ID}} {{.Names}}' | grep -vE "(${keywords})" | awk '{print $1}')" 2>/dev/null || true
    docker rmi "$(docker images --format '{{.ID}} {{.Repository}}' | grep -vE "(${keywords})" | awk '{print $1}')" 2>/dev/null || true
  fi
}

# ------------------------------- JS Ecosystem ------------------------------- #

nvm:update() {
  if ! nvm install node --latest-npm 2>&1 | tee /dev/null | grep -q "already installed"; then
    nvm use node
    node:verify
  fi
}

node:verify() {
  # Check if node command works after switching to newest version
  if ! node --version >/dev/null 2>&1; then
    echo "Warning: node command failed with newest version, reverting to LTS..."
    # Fallback to the LTS version
    nvm alias default 'lts/*'
    nvm use --lts
    echo "Reverted to LTS node version."
  fi

  # shellcheck disable=SC2155
  local node_version=$(node --version)

  mkdir -p "${NPM_GLOBALS_LOCK_DIR}"
  local installed_globals_file="${NPM_GLOBALS_LOCK_DIR}/.npm.globals.${node_version}.lock"

  if [ ! -f "${installed_globals_file}" ] || [ -f "${HOME}/.npm.globals" ] && [ "$(wc -l <"${installed_globals_file}" 2>/dev/null || echo 0)" -lt "$(grep -cvE '^#|^$' "${HOME}/.npm.globals" 2>/dev/null || echo 1)" ]; then
    globals:install
  fi
}

bun:update() {
  bun upgrade &>/dev/null
}

nvmrc:load() {
  # shellcheck disable=SC2155
  local nvmrc_path="$(nvm_find_nvmrc)"

  if [[ -n "${nvmrc_path}" ]]; then
    # shellcheck disable=SC2155
    local nvmrc_node_version=$(nvm version "$(cat "${nvmrc_path}")")

    if [[ "${nvmrc_node_version}" == "N/A" ]]; then
      nvm install
    elif [[ "${nvmrc_node_version}" != "$(nvm version)" ]]; then
      nvm use
    fi
  elif [[ -n "$(PWD=${OLDPWD} nvm_find_nvmrc)" ]] && [[ "$(nvm version)" != "$(nvm version default)" ]]; then
    echo "Reverting to nvm default version"
    nvm use default
  fi
}

globals:install() {
  if [ -f "$NPM_GLOBALS" ]; then
    grep -vE '^#|^$' "$NPM_GLOBALS" | xargs npm install -g --force

    # shellcheck disable=SC2155
    local node_version=$(node --version)

    mkdir -p "${NPM_GLOBALS_LOCK_DIR}"
    local lock_file="${NPM_GLOBALS_LOCK_DIR}/.npm.globals.${node_version}.lock"
    grep -vE '^#|^$' "$NPM_GLOBALS" >"${lock_file}"

    echo "Global packages installed."
  else
    echo ".npm.globals file not found."
  fi
}

ncu:update() {
  ncu -u
  rm -rf node_modules
  rm -f yarn.lock package-lock.json pnpm-lock.yaml bun.lock
  ni
}

# --------------------- Environment Management Functions --------------------- #

# Load .env file into shell environment
env:load() {
  local env_file="${1:-$HOME/.env}"
  if [[ -f "$env_file" ]]; then
    local loaded_count=0
    
    # Process each line
    while IFS= read -r line || [[ -n "$line" ]]; do
      # Skip comments and empty lines
      [[ "$line" =~ ^[[:space:]]*# ]] && continue
      [[ -z "${line// }" ]] && continue
      
      # Validate format (KEY=VALUE) and export
      if [[ "$line" =~ ^[a-zA-Z_][a-zA-Z0-9_]*= ]]; then
        local key="${line%%=*}"
        local value="${line#*=}"
        export "${key}=${value}"
        ((loaded_count++))
      fi
    done < "$env_file"
  fi
}

# Replace environment variables in npmrc and load .env
env:replace() {
  # First load the .env file into the shell environment
  env:load "$HOME/.env"
  
  # Then run the npmrc replacement
  if [[ -f "${HOME}/.env" ]]; then
    CURRENT_DIR=$(pwd)
    cd "$HOME" || exit

    npx npmrc-replace-env -w
    cd "$CURRENT_DIR" || exit
  else
    echo ".env file not found."
  fi
}

# --------------------------- Dotfiles Management ---------------------------- #

# Create a symbolic link from source to target, removing existing target if necessary
dotfiles:symlink() {
  local source_file="$1"
  local target_file="$2"

  if [[ ! -e "$source_file" ]]; then
    print error "Source file not found: $source_file (skipping)" >&2
    return 1
  fi

  if [[ -e "$target_file" || -L "$target_file" ]]; then
    print warning "Removing existing $target_file"
    rm -rf "$target_file"
  fi

  ln -s "$source_file" "$target_file"
  print success "Created symlink for $(basename "$source_file") at $target_file"
}

# Remove a symbolic link or file
dotfiles:remove() {
  local target_file="$2" # Matches signature of dotfiles:symlink (source, target)

  if [[ -L "$target_file" || -e "$target_file" ]]; then
    rm -rf "$target_file"
    print success "Removed $target_file"
  fi
}

# Generic iterator for dotfiles operations
dotfiles:iterate() {
  local cmd="$1"
  local source_dir="$2"
  local target_dir="$3"
  local skip_list="${4:-.DS_Store .git .gitignore LICENSE README.md}"
  shift 4
  local files=("$@")

  if [[ ! -d "$source_dir" ]]; then
    print error "Source dir not found: $source_dir (skipping)" >&2
    return 1
  fi

  if [[ ! -d "$target_dir" ]]; then
    print error "Target dir not found: $target_dir (skipping)" >&2
    return 1
  fi

  if (( ${#files[@]} > 0 )); then
    for filename in "${files[@]}"; do
      "$cmd" "$source_dir/$filename" "$target_dir/$filename"
    done
  else
    # shellcheck disable=SC2206
    local -a skip_files=($skip_list)
    for file in "$source_dir"/.*; do
      # shellcheck disable=SC2155
      local filename=$(basename "$file")

      [[ "$filename" == "." || "$filename" == ".." ]] && continue

      if [[ " ${skip_files[*]} " == *" $filename "* ]]; then
        # Only warn on skip if we are linking, to avoid noise when unlinking
        [[ "$cmd" == "dotfiles:symlink" ]] && print info "Skipping $filename"
        continue
      fi

      "$cmd" "$file" "$target_dir/$filename"
    done
  fi
}

# Helper to process dotfiles (link or unlink)
dotfiles:process() {
  local cmd="$1"
  shift
  (( $# == 0 )) && set -- "${DOTFILES_REPO_PATH}/.home" "${DOTFILES_CONFIG_PATH_PROTECTED}"
  local -a source_dirs=("${@}")

  # Process dotfiles & secrets in home directory
  for source_dir in "${source_dirs[@]}"; do
    dotfiles:iterate "$cmd" "$source_dir" "$HOME" ""
  done

  # Process VSCode settings files
  if [[ -d "$VSCODE_CONFIG_PATH" ]]; then
    dotfiles:iterate "$cmd" "${DOTFILES_REPO_PATH}/.vscode" "$VSCODE_CONFIG_PATH" "" "settings.json" "keybindings.json"
  elif [[ "$cmd" == "dotfiles:symlink" ]]; then
    echo "Directory not found: $VSCODE_CONFIG_PATH (skipping)" >&2
  fi
}

# Main entry point to link dotfiles from repo/config paths to $HOME
dotfiles:link() {
  dotfiles:process "dotfiles:symlink" "$@"
}

# Main entry point to unlink dotfiles
dotfiles:unlink() {
  dotfiles:process "dotfiles:remove" "$@"
}
# ------------------------------------ Git ----------------------------------- #

# Use Git’s colored diff when available
hash git &>/dev/null;
if [ $? -eq 0 ]; then
	diff() {
		git diff --no-index --color-words "$@";
	}
fi;

git:diff() {
  local source_branch="$1"
  local target_branch="$2"
  local exclude_pattern="$3"

  if [[ -n "$exclude_pattern" ]]; then
    git diff --name-only "$source_branch...$target_branch" -- ":!$exclude_pattern" | while read -r file; do
      echo -e "\n$file:\n"
      git show "$target_branch:$file"
    done | pbcopy
  else
    git diff --name-only "$source_branch...$target_branch" | while read -r file; do
      echo -e "\n$file:\n"
      git show "$target_branch:$file"
    done | pbcopy
  fi

  echo "Diff output copied to clipboard."
}

git:history() {
  editor="code"
  editor_args=""
  while [ $# -gt 0 ]; do
    case "$1" in
    --editor)
      shift
      if [ $# -eq 0 ]; then
        printf 'Error: --editor requires an argument.\n' >&2
        return 1
      fi
      editor="$1"
      shift
      ;;
    --)
      shift
      editor_args="$*"
      break
      ;;
    *)
      printf 'Usage: git:history [--editor <editor>] [-- <editor_args>]\n' >&2
      return 1
      ;;
    esac
  done

  if ! git rev-parse --git-dir >/dev/null 2>&1; then
    printf 'Error: Not a git repository.\n' >&2
    return 1
  fi

  tmpfile=$(mktemp -t git-history-XXXXXX)
  git log --pretty=medium >"$tmpfile"

  if ! command -v "$editor" >/dev/null 2>&1; then
    printf 'Error: Editor "%s" not found.\n' "$editor" >&2
    rm -f "$tmpfile"
    return 1
  fi

  if [ -z "$editor_args" ]; then
    case "$editor" in
    code | idea)
      editor_args="--wait"
      ;;
    esac
  fi

  if [ -n "$editor_args" ]; then
    $editor "$editor_args" "$tmpfile" || {
      printf 'Error: Editor exited with an error.\n' >&2
      rm -f "$tmpfile"
      return 1
    }
  else
    $editor "$tmpfile" || {
      printf 'Error: Editor exited with an error.\n' >&2
      rm -f "$tmpfile"
      return 1
    }
  fi

  printf 'Are you sure you want to rewrite the entire git history? (Yes/No): '
  read confirmation
  case "$confirmation" in
  Yes | yes) ;;
  *)
    printf 'Aborted by user.\n'
    rm -f "$tmpfile"
    return 1
    ;;
  esac

  # Create a temporary mapping directory.
  mapping_dir=$(mktemp -d -t git-history-map-XXXXXX)

  # Process the git log output to build mapping files.
  commit_hash=""
  author=""
  email=""
  date=""
  message=""
  in_message=0
  first_message_line=1

  while IFS= read -r line || [ -n "$line" ]; do
    case "$line" in
    commit\ *)
      if [ -n "$commit_hash" ]; then
        # Write out the mapping for the previous commit.
        {
          printf "%s\n" "$author"
          printf "%s\n" "$email"
          printf "%s\n" "$date"
          printf "\n"
          printf "%s\n" "$message"
        } >"$mapping_dir/$commit_hash"
      fi
      commit_hash=$(printf '%s' "$line" | sed 's/^commit //')
      author=""
      email=""
      date=""
      message=""
      in_message=0
      first_message_line=1
      ;;
    Merge:\ *)
      # Ignore merge header lines.
      ;;
    Author:\ *)
      author_line=$(printf '%s' "$line" | sed 's/^Author: //')
      author=$(printf '%s' "$author_line" | sed 's/ <.*//')
      email=$(printf '%s' "$author_line" | sed 's/^.*<//; s/>$//')
      ;;
    Date:\ *)
      date=$(printf '%s' "$line" | sed 's/^Date: //; s/^ *//; s/ *$//')
      ;;
    "")
      if [ $in_message -eq 1 ]; then
        message="$message
"
      else
        in_message=1
        first_message_line=1
      fi
      ;;
    *)
      if [ $in_message -eq 1 ]; then
        trimmed=$(printf '%s' "$line" | sed 's/^    //')
        if [ $first_message_line -eq 1 ]; then
          message="$message$trimmed"
          first_message_line=0
        else
          message="$message
$trimmed"
        fi
      fi
      ;;
    esac
  done <"$tmpfile"

  # Write mapping for the last commit (if any).
  if [ -n "$commit_hash" ]; then
    {
      printf "%s\n" "$author"
      printf "%s\n" "$email"
      printf "%s\n" "$date"
      printf "\n"
      printf "%s\n" "$message"
    } >"$mapping_dir/$commit_hash"
  fi

  rm -f "$tmpfile"
  export MAPPING_DIR="$mapping_dir"

  # Rewrite history using filter-branch, looking up metadata by commit hash.
  FILTER_BRANCH_SQUELCH_WARNING=1 git filter-branch -f \
    --env-filter '
      if [ -f "$MAPPING_DIR/$GIT_COMMIT" ]; then
        a=$(sed -n "1p" "$MAPPING_DIR/$GIT_COMMIT")
        e=$(sed -n "2p" "$MAPPING_DIR/$GIT_COMMIT")
        d=$(sed -n "3p" "$MAPPING_DIR/$GIT_COMMIT")
        if [ -n "$a" ]; then
          GIT_AUTHOR_NAME="$a"
          GIT_AUTHOR_EMAIL="$e"
          GIT_AUTHOR_DATE="$d"
          GIT_COMMITTER_NAME="$a"
          GIT_COMMITTER_EMAIL="$e"
          GIT_COMMITTER_DATE="$d"
          export GIT_AUTHOR_NAME GIT_AUTHOR_EMAIL GIT_AUTHOR_DATE
          export GIT_COMMITTER_NAME GIT_COMMITTER_EMAIL GIT_COMMITTER_DATE
        fi
      fi
    ' \
    --msg-filter '
      if [ -f "$MAPPING_DIR/$GIT_COMMIT" ]; then
        # Delete the first 4 lines (author, email, date, blank) and output the remainder as the commit message.
        m=$(sed "1,4d" "$MAPPING_DIR/$GIT_COMMIT")
        if [ -n "$m" ]; then
          printf "%s\n" "$m"
        else
          cat
        fi
      else
        cat
      fi
    ' \
    -- --all || {
    printf 'Error: Failed to rewrite Git history.\n' >&2
    rm -rf "$MAPPING_DIR"
    return 1
  }

  # Clean up the mapping directory.
  rm -rf "$MAPPING_DIR"

  printf 'Git history has been rewritten successfully.\n'
  printf 'Note: If you have already pushed this branch, you will need to force push:\n'
  printf 'git push --force-with-lease\n'
}
